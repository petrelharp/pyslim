.. _sec_vignette_coalescent_diversity:

====================================================================
Vignette: Starting with diversity generated by coalescent simulation
====================================================================

This vignette shows how to simulate history with msprime,
add SLiM mutations to it and assign them selection coefficients,
then run a SLiM simulating using this as a starting point.

Simulations of large populations with selection can be costly,
especially if we need to run a lengthy "burn-in" period to get the
genetic diversity for selection to act on.
Sometimes, the precise form of the burn-in is not important,
and so a *neutral* burn-in is acceptable - allowing us to use msprime.
For instance, suppose we'd like to simulate a lab experiment
in which we take high-diversity organisms from the wild and subject them
to selection for a few dozen generations.
Genetic diversity in the wild is certainly not neutral, but then again,
we don't quite know what it *does* look like, so a coalescent simulation
would be better than nothing. The key attribute of reality we'd like to
approximate is the joint distribution of allele frequencies and effect
sizes. If the alleles affect a trait under stabilizing selection, we'd
expect a negative correlation between the two. On the other hand,
if the trait we're selecting on in the lab is not under strong selection
in the wild, there might not be much of a relationship.
This is a simple example, to show how to do this:
the trait under selection is just fitness,
and there is no relationship between allele frequency and effect size.


************************
The colescent simulation
************************

First, we'll simulate demographic history of 2,000 chromosomes
across a smallish chromosome (:math:`N_e = 10,0000` diploids)
from a relatively large population, using msprime.

.. code-block:: python

   import msprime, pyslim, tskit
   import numpy as np

   ots = msprime.simulate(
            2000,
            Ne=10000,
            length=1e7,
            random_seed=5,
            discrete_genome=True, 
            recombination_rate=1e-8)

*****************
Annotate everyone
*****************

At this point, we have genealogical information: individuals,
nodes (chromosomes), and relationships between them,
but no genetic diversity; no mutations.
First, we'll add SLiM metadata to all of these things,
a procedure we call "annotating".

.. note::

   We have to annotate before adding mutations, because 
   because the :meth:`.annotate_defaults` method overwrites existing
   metadata.

.. code-block:: python

   ots = pyslim.annotate_defaults(ots, model_type="WF", slim_generation=1)

This method adds default metadata to everything that needs it:
in this case, all individuals, all nodes that are part of alive individuals,
and all populations referenced by nodes.

******************
Add SLiM mutations
******************

Next, we're going to use the :meth:`msprime.SlimMutationModel` to add mutations
to the tree sequence. These will carry SLiM metadata, but this metadata
will say that the mutations are neutral. So, we'll then need to modify their metadata
after the fact to have selection coefficients drawn from some distribution.
We'll want this to be as if we'd done in a burn-in script in SLiM:

.. code-block::

   initialize() {
      ...
      initializeMutationType(1, 0.5, "e", 0.03);
      initializeMutationRate(1e-10);
   }

   fitness() {
       return 1.0;
   }


In other words, we'd like to pull selection coefficients from an exponential distribution
with mean 0.03 (but, of course, this is a coalescent simulation, so the mutations
are in fact neutral).
Note that the dominance coefficient is *not* stored in the tree sequence:
it gets set in the SLiM recipe.
Here's how to add SLiM mutations with msprime:

.. code-block:: python

   mut_model = msprime.SlimMutationModel(type=1)
   ots = msprime.mutate(ots, rate=1e-10, model=mut_model, discrete=True, random_seed=5)
   print(f"The tree sequence now has {ots.num_mutations} mutations, at "
         f"{ots.num_sites} distinct sites.")
   # The tree sequence now has 320 mutations, at 319 distinct sites.

Note the ``type=1`` argument to :meth:`msprime.SlimMutationModel`:
this means the mutations will be of type "m1" in SLiM (and, so you must
initialize that mutation type in the recipe that loads this tree sequence in).

Now, we'll assign selection coefficients.
Recall that to accomodate mutation stacking in SLiM,
a mutation metadata entry is in fact a *list* of metadata entries,
one for each of the SLiM mutations that are stacked at this position.
The SLiM IDs of these mutations are available (in the same order)
as a comma-separated list of integers in the derived state of the mutation.
So, in case some SLiM mutations appear in more than one mutation
in the tree sequence, we will build a map from SLiM ID to selection coefficient:
``mut_map[k]`` will give the selection coefficient of the SLiM mutation with
SLiM mutation ID ``k``.

.. code-block:: python

   tables = ots.tables
   tables.mutations.clear()
   mut_map = {}
   for m in ots.mutations():
      md_list = m.metadata["mutation_list"]
      slim_ids = m.derived_state.split(",")
      assert len(slim_ids) == len(md_list)
      for sid, md in zip(slim_ids, md_list):
         if sid not in mut_map:
            mut_map[sid] = np.random.exponential(scale=0.03)
         md["selection_coeff"] = mut_map[sid]
      _ = tables.mutations.add_row(
         site=m.site,
         node=m.node,
         time=m.time,
         derived_state=m.derived_state,
         parent=m.parent,
         metadata={"mutation_list": md_list})

   # check we didn't mess anything up
   assert tables.mutations.num_rows == ots.num_mutations
   print(f"The selection coefficients range from {min(mut_map.values())} "
         f"to {max(mut_map.values())}.")
   # The selection coefficients range from 5.9166379253869124e-06 to 0.19540735762228165.



**************
Load into SLiM
**************

Before loading the tree sequence into SLiM, we should check the top-level metadata.
We can see this with ``tables.metadata``:

.. code-block:: python

   {'SLiM':
           {'file_version': '0.5',
            'generation': 1,
            'model_type': 'WF',
            'nucleotide_based': False,
            'separate_sexes': False,
            'spatial_dimensionality': '',
            'spatial_periodicity': '',
            'stage': 'late'}
   }

We should edit this to match our planned slimulation
- particularly the ``model_type`` (WF or nonWF) and the ``generation``.
The ``generation`` tells SLiM what generation to set the generation counter to
once this tree sequence is loaded. In principle, it can be set to anything,
independently of the times in the tree sequence,
because the times in the tree sequence are measured in units of
"time before the end"; and the ``generation`` that gets
passed to SLiM sets what that "end time" is, in SLiM's time.
However, if you change this, the ``slim_time`` attributes in mutation metadata
will not be accurate. This is harmless, unless you do something with mutations'
times yourself.

The ``model_type`` is already Wright-Fisher, but just to demonstrate how to
edit the metadata, let's make sure,
and then we'll write the tree sequence to a file.

.. code-block:: python

   ts_metadata = tables.metadata
   ts_metadata["SLiM"]["model_type"] = "WF"
   tables.metadata = ts_metadata
   ots = tables.tree_sequence()
   ots.dump("vignette_annotated.init.trees")

Now for the SLiM recipe.
This simply continues selected mutations as before
(with mutation rate 1e-10 per bp per generation
and the same distribution of fitness effects).
The population size is determined by the number of individuals that were
read in from the tree sequence.
We need to make sure that the genome lengths match,
so we provide that as a constant ``L``, that will be provided at run time.
To facilitate later analysis, we'll also "Remember" the individuals
present at the *start* of the simulation,
so that they will remain in the tree sequence.

.. literalinclude:: reload_annotated.slim

We could run this on the command line as
``slim -d L=100000000 reload_annotated.slim``,
but it's a bit more convenient to stay within python,
and obtain the sequence length programatically:

.. code-block:: python

   import subprocess
   subprocess.check_output(
         ["slim", "-d", f"L={int(ots.sequence_length)}",
          "-s", "5", "docs/reload_annotated.slim"])

This runs quickly, since it's only 100 generations.

***************
Analyze results
***************

First, let's look at what mutations are present:

.. code-block:: python

   ts = pyslim.load("vignette_annotated.trees")
   num_stacked = np.array([len(m.metadata["mutation_list"]) for m in ts.mutations()])
   old_mut = np.array([m.time > ts.slim_generation for m in ts.mutations()])
   assert(sum(old_mut) == ots.num_mutations)
   print(f"There are {ts.num_mutations} present at {ts.num_sites} distinct sites.")
   print(f"Of these, {np.sum(num_stacked > 1)} have more than one stacked mutation,")
   print(f"and {np.sum(old_mut)} were produced by msprime.")


Most of the mutations were present as initial diversity,
but a few were added during the course of the simulation.
A simple thing to look at next is: how did the selected mutations
change in frequency? We can do this thanks to our having
Remembered the first generation.
First, we'll compute all allele frequencies
among both the first generation and the final generation:

.. code-block:: python

   times = list(set(ts.individual_times))
   times.sort()
   print("The times at which individuals in the tree sequence were born:", times)
   # The times at which individuals in the tree sequence were born: [0.0, 100.0]
   inds_by_time = [ts.individuals_alive_at(t) for t in times]
   nodes_by_time = []
   for inds in inds_by_time:
      nodes = np.array([ts.individual(i).nodes for i in inds]).flatten()
      nodes_by_time.append(nodes)

   num_nodes = np.array([len(x) for x in nodes_by_time])
   p = ts.sample_count_stat(nodes_by_time, lambda x: x/num_nodes, 2, windows='sites',
            strict=False, span_normalise=False, polarised=True)
   s = np.array([sum([sum([md["selection_coeff"] for md in m.metadata["mutation_list"]])
                      for m in site.mutations]) for site in ts.sites()])

To do this, we used :meth:`.SlimTreeSequence.individuals_alive_at` to find the individuals
alive at each of the two times (0 and 100 generations ago);
extracted the list of nodes corresponding to each of these lists of individuals,
then computed an array ``p`` of allele frequencies, with one row per site,
the first column giving the frequency among the initial generation,
and the second giving the frequency at the end.
We also pull out ``s``, the selection coefficients.
This last bit is a bit complex because each site can have more than one mutation,
and each tree sequence mutation can represent more than one SLiM mutation.
And, the way we've dealt with this is a bit of a hack,
so let's look at that site with multiple mutations:

.. code-block:: python

   for j, v in enumerate(ts.variants()):
      if len(v.site.mutations) > 1:
         print(f"Site {j} has {num_stacked[j]} stacked mutations, "
               f"with total derived allele frequency {p[j]} "
               f"and sum of selection coefficients {s[j]}.")
         print(f"The allele frequencies are:")
         for k, a in enumerate(v.alleles):
            print(f"  '{a}': {sum(v.genotypes == k)}")
         print(v.site)

This produces

.. code-block:: python

   # Site 184 has 1 stacked mutations, with total derived allele frequency [0.735 0.045] and sum of selection coefficients 0.04058143601287156.
   # ''   : 2440
   # '178': 1550
   # '179': 10
   {'id': 184, 'position': 5629844.0, 'ancestral_state': '',
    'mutations': [
      {'id': 184, 'site': 184, 'node': 15521, 'time': nan, 'derived_state': '178', 'parent': -1,
       'metadata': {'mutation_list': [
          {'mutation_type': 1, 'selection_coeff': 0.03935328871011734,
           'subpopulation': -1, 'slim_time': 0, 'nucleotide': -1}
         ]}},
      {'id': 185, 'site': 184, 'node': 8100, 'time': nan, 'derived_state': '179', 'parent': -1,
       'metadata': {'mutation_list': [
          {'mutation_type': 1, 'selection_coeff': 0.0012281473027542233,
           'subpopulation': -1, 'slim_time': 0, 'nucleotide': -1}]}}
     ], 'metadata': b''}

It looks like there were two independent mutations at this site: neither of them resulted
in a "stacked" mutation. One, present in 1550 copies, had a higher selection coefficient (0.039)
than the other, present in only 10 copies (s=0.001).
      

Now, we'll plot the initial and final allele frequencies,
with point size and color determined by the selection coefficient:

.. code-block:: python

   import matplotlib
   matplotlib.use('Agg')
   import matplotlib.pyplot as plt

   fig, ax1 = plt.subplots(figsize=(5, 4))
   dp = ax1.scatter(p[:, 0], p[:,1], c=s, s=s*800, label='frequencies')
   ax1.set_xlabel("initial allele frequency")
   ax1.set_ylabel("final allele frequency")
   fig.colorbar(dp, ax=ax1, label='selection coefficient')
   fig.savefig("annotated_p_vs_s.pdf")
   

This produces

.. image:: _static/annotated_p_vs_s.png


Unsurprisingly, mutations that had a large change in allele frequency seem
to be biased towards ones with higher selection coefficients.
