.. _sec_vignette_coalescent_diversity:

====================================================================
Vignette: Starting with diversity generated by coalescent simulation
====================================================================

This vignette shows how to simulate history with msprime,
add SLiM mutations to it and assign them selection coefficients,
then run a SLiM simulating using this as a starting point.

Simulations of large populations with selection can be costly,
especially if we need to run a lengthy "burn-in" period to get the
genetic diversity for selection to act on.
Sometimes, the precise form of the burn-in is not important,
and so a *neutral* burn-in is acceptable - allowing us to use msprime.
For instance, suppose we'd like to simulate a lab experiment
in which we take high-diversity organisms from the wild and subject them
to selection for a few dozen generations.
Genetic diversity in the wild is certainly not neutral, but then again,
we don't quite know what it *does* look like, so a coalescent simulation
would be better than nothing. The key attribute of reality we'd like to
approximate is the joint distribution of allele frequencies and effect
sizes. If the alleles affect a trait under stabilizing selection, we'd
expect a negative correlation between the two. On the other hand,
if the trait we're selecting on in the lab is not under strong selection
in the wild, there might not be much of a relationship.
This is a simple example, to show how to do this:
the trait under selection is just fitness,
and there is no relationship between allele frequency and effect size.

The steps will be:

1. Run a coalescent simulation with msprime.
2. Add SLiM metadata to the nodes, individuals, and populations.
3. Add SLiM mutations with msprime,
   and edit the mutation metadata to assign selection coefficients.
4. Run the SLiM portion of the simulation.
5. Do some descriptive analysis of the results of selection.
6. Add neutral mutations to the tree sequence.
7. Do some descriptive analysis of genetic diversity along the genome.


*******************************
Mutation and recombination maps
*******************************

In this model, we'll also demonstrate how to modulate mutation and recombination rate
along the genome. We'll do a simple example: a 9MB genome
with three equally-sized domains.
The first and last third of the genome will have high recombination
(5e-8 per generation per bp),
and the middle third will have low recombination
(0.5e-8 per generation per bp).
The mutation rate will be constant (1e-8 per generation per bp),
but a lower proportion of mutations in the middle region are under selection:
on the outside thirds, 3% of mutations are beneficial with a selection coefficient
drawn from an Exponential distribution,
and in the middle third, only 0.3% are (but with the same distribution of selection coefficients).
This implies that the mutation rate *of beneficial mutations* on the ends
is :math:`0.03 \times 10^{-8}` = 3e-10, and in the middle is 3e-11.
We'll simulate these first, and only add the neutral mutations after everything else,
at rates 1e-8 - 3e-10 on the ends, and 1e-8 - 3e-11 in the middle.


************************
The colescent simulation
************************

First, we'll simulate demographic history of 2,000 chromosomes
across a smallish chromosome (:math:`N_e = 10,0000` diploids)
from a relatively large population, using msprime.

.. code-block:: python

   import msprime, pyslim, tskit
   import numpy as np

   breaks = [0, 3000000, 6000000, 9000000]
   recomb_map = msprime.RecombinationMap(
      positions = breaks,
      rates = [5e-8, 0.5e-8, 5e-8] + [0.0])
   ots = msprime.simulate(
            2000,
            Ne=10000,
            random_seed=5,
            discrete_genome=True, 
            recombination_map=recomb_map)

*****************
Annotate everyone
*****************

At this point, we have genealogical information: individuals,
nodes (chromosomes), and relationships between them,
but no genetic diversity; no mutations.
First, we'll add SLiM metadata to all of these things,
a procedure we call "annotating".

.. note::

   We have to annotate before adding mutations, because 
   because the :meth:`.annotate_defaults` method overwrites existing
   metadata.

.. code-block:: python

   ots = pyslim.annotate_defaults(ots, model_type="WF", slim_generation=1)

This method adds default metadata to everything that needs it:
in this case, all individuals, all nodes that are part of alive individuals,
and all populations referenced by nodes.

******************
Add SLiM mutations
******************

Next, we're going to use the :meth:`msprime.SlimMutationModel` to add mutations
to the tree sequence. These will carry SLiM metadata, but this metadata
will say that the mutations are neutral. So, we'll then need to modify their metadata
after the fact to have selection coefficients drawn from some distribution.
We'll want this to be as if we'd done in a burn-in script in SLiM:

.. code-block::

   initialize() {
      ...
      initializeMutationType(2, 0.5, "e", 0.03);
      initializeMutationRate(1e-10);
   }

   fitness() {
       return 1.0;
   }


In other words, we'd like to pull selection coefficients from an exponential distribution
with mean 0.03 (but, of course, this is a coalescent simulation, so the mutations
are in fact neutral).
Note that the dominance coefficient is *not* stored in the tree sequence:
it gets set in the SLiM recipe.
Here's how to add SLiM mutations with msprime:

.. code-block:: python

   mut_map = msprime.RateMap(
               position=breaks,
               rate=[0.03e-8, 0.003e-8, 0.03e-8])
   mut_model = msprime.SlimMutationModel(type=2)
   ots = msprime.mutate(ots, rate=mut_map, model=mut_model, discrete=True, random_seed=9)
   print(f"The tree sequence now has {ots.num_mutations} mutations, at "
         f"{ots.num_sites} distinct sites.")
   # The tree sequence now has 668 mutations, at 667 distinct sites.

Note the ``type=2`` argument to :meth:`msprime.SlimMutationModel`:
this means the mutations will be of type "m2" in SLiM (and, so you must
initialize that mutation type in the recipe that loads this tree sequence in).

Now, we'll assign selection coefficients.
Recall that to accomodate mutation stacking in SLiM,
a mutation metadata entry is in fact a *list* of metadata entries,
one for each of the SLiM mutations that are stacked at this position.
The SLiM IDs of these mutations are available (in the same order)
as a comma-separated list of integers in the derived state of the mutation.
So, in case some SLiM mutations appear in more than one mutation
in the tree sequence, we will build a map from SLiM ID to selection coefficient:
``mut_map[k]`` will give the selection coefficient of the SLiM mutation with
SLiM mutation ID ``k``.

.. code-block:: python

   tables = ots.tables
   tables.mutations.clear()
   mut_map = {}
   for m in ots.mutations():
      md_list = m.metadata["mutation_list"]
      slim_ids = m.derived_state.split(",")
      assert len(slim_ids) == len(md_list)
      for sid, md in zip(slim_ids, md_list):
         if sid not in mut_map:
            mut_map[sid] = np.random.exponential(scale=0.03)
         md["selection_coeff"] = mut_map[sid]
      _ = tables.mutations.add_row(
         site=m.site,
         node=m.node,
         time=m.time,
         derived_state=m.derived_state,
         parent=m.parent,
         metadata={"mutation_list": md_list})

   # check we didn't mess anything up
   assert tables.mutations.num_rows == ots.num_mutations
   print(f"The selection coefficients range from {min(mut_map.values())} "
         f"to {max(mut_map.values())}.")
   # The selection coefficients range from 8.639067134728749e-06 to 0.2547625650566081.



**************
Load into SLiM
**************

Before loading the tree sequence into SLiM, we should check the top-level metadata.
We can see this with ``tables.metadata``:

.. code-block:: python

   {'SLiM':
           {'file_version': '0.5',
            'generation': 1,
            'model_type': 'WF',
            'nucleotide_based': False,
            'separate_sexes': False,
            'spatial_dimensionality': '',
            'spatial_periodicity': '',
            'stage': 'late'}
   }

We should edit this to match our planned slimulation
- particularly the ``model_type`` (WF or nonWF) and the ``generation``.
The ``generation`` tells SLiM what generation to set the generation counter to
once this tree sequence is loaded. In principle, it can be set to anything,
independently of the times in the tree sequence,
because the times in the tree sequence are measured in units of
"time before the end"; and the ``generation`` that gets
passed to SLiM sets what that "end time" is, in SLiM's time.
However, if you change this, the ``slim_time`` attributes in mutation metadata
will not be accurate. This is harmless, unless you do something with mutations'
times yourself.

The ``model_type`` is already Wright-Fisher, but just to demonstrate how to
edit the metadata, let's make sure,
and then we'll write the tree sequence to a file.

.. code-block:: python

   ts_metadata = tables.metadata
   ts_metadata["SLiM"]["model_type"] = "WF"
   tables.metadata = ts_metadata
   ots = tables.tree_sequence()
   ots.dump("vignette_annotated.init.trees")

Now for the SLiM recipe.
This simply continues selected mutations as before
(with mutation rate 1e-10 per bp per generation
and the same distribution of fitness effects).
The population size is determined by the number of individuals that were
read in from the tree sequence.
We need to make sure that the genome lengths match,
so we provide that as a constant ``L``, that will be provided at run time.
To facilitate later analysis, we'll also "Remember" the individuals
present at the *start* of the simulation,
so that they will remain in the tree sequence.

.. literalinclude:: reload_annotated.slim

Note that the simulation only has selected mutations (of type ``m2``),
but as we'll add in type ``m1`` mutations later,
we've declared them in the recipe as a placeholder.

We could run this on the command line as
``slim -d L=100000000 reload_annotated.slim``,
but it's a bit more convenient to stay within python,
and obtain the sequence length programatically:

.. code-block:: python

   import subprocess
   subprocess.check_output(
         ["slim", "-d", f"L={int(ots.sequence_length - 1)}",
          "-s", "5", "reload_annotated.slim"])

This runs quickly, since it's only 100 generations.

***************
Analyze results
***************

First, let's look at what mutations are present:

.. code-block:: python

   ts = pyslim.load("vignette_annotated.trees")
   num_stacked = np.array([len(m.metadata["mutation_list"]) for m in ts.mutations()])
   old_mut = np.array([m.time > ts.slim_generation for m in ts.mutations()])
   assert(sum(old_mut) == ots.num_mutations)
   print(f"There are {ts.num_mutations} present at {ts.num_sites} distinct sites.")
   print(f"Of these, {np.sum(num_stacked > 1)} have more than one stacked mutation,")
   print(f"and {np.sum(old_mut)} were produced by msprime.")
   # There are 697 present at 696 distinct sites.
   # Of these, 1 have more than one stacked mutation,
   # and 668 were produced by msprime.

Most of the mutations were present as initial diversity,
but a few were added during the course of the simulation.
A simple thing to look at next is: how did the selected mutations
change in frequency? We can do this thanks to our having
Remembered the first generation.
First, we'll compute all allele frequencies
among both the first generation and the final generation:

.. code-block:: python

   times = list(set(ts.individual_times))
   times.sort()
   print("The times at which individuals in the tree sequence were born:", times)
   # The times at which individuals in the tree sequence were born: [0.0, 100.0]
   inds_by_time = [ts.individuals_alive_at(t) for t in times]
   nodes_by_time = []
   for inds in inds_by_time:
      nodes = np.array([ts.individual(i).nodes for i in inds]).flatten()
      nodes_by_time.append(nodes)

   num_nodes = np.array([len(x) for x in nodes_by_time])
   p = ts.sample_count_stat(nodes_by_time, lambda x: x/num_nodes, 2, windows='sites',
            strict=False, span_normalise=False, polarised=True)
   s = np.array([sum([sum([md["selection_coeff"] for md in m.metadata["mutation_list"]])
                      for m in site.mutations]) for site in ts.sites()])

To do this, we used :meth:`.SlimTreeSequence.individuals_alive_at` to find the individuals
alive at each of the two times (0 and 100 generations ago);
extracted the list of nodes corresponding to each of these lists of individuals,
then computed an array ``p`` of allele frequencies, with one row per site,
the first column giving the frequency among the initial generation,
and the second giving the frequency at the end.
We also pull out ``s``, the selection coefficients.
This last bit is a bit complex because each site can have more than one mutation,
and each tree sequence mutation can represent more than one SLiM mutation.
And, the way we've dealt with this is a bit of a hack,
so let's look at that site with multiple mutations:

.. code-block:: python

   for j, v in enumerate(ts.variants()):
      if len(v.site.mutations) > 1:
         print(f"Site {j} has {num_stacked[j]} stacked mutations, "
               f"with total derived allele frequency {p[j]} "
               f"and sum of selection coefficients {s[j]}.")
         print(f"The allele frequencies are:")
         for k, a in enumerate(v.alleles):
            print(f"  '{a}': {sum(v.genotypes == k)}")
         print(v.site)

This produces

.. code-block:: python

   # Site 489 has 1 stacked mutations,
   # with total derived allele frequency [0.9945 0.5325]
   # and sum of selection coefficients 0.04661317712816526.
   # The allele frequencies are:
   #   '': 946
   #   '8455': 0
   #   '8455,8456': 3054
   {'id': 489, 'position': 7042081.0, 'ancestral_state': '', 'mutations': [
      {'id': 489, 'site': 489, 'node': 57371, 'time': 46014.624287471925,
       'derived_state': '8455', 'parent': -1,
       'metadata': {'mutation_list': [
         {'mutation_type': 2, 'selection_coeff': 1.5805397197254933e-05,
          'subpopulation': -1, 'slim_time': 0, 'nucleotide': -1}
       ]}},
      {'id': 490, 'site': 489, 'node': 57371, 'time': 27968.53966967204,,
       'derived_state': '8455,8456', 'parent': 489,
       'metadata': {'mutation_list': [
         {'mutation_type': 2, 'selection_coeff': 1.5805397197254933e-05,
          'subpopulation': -1, 'slim_time': 0, 'nucleotide': -1},
         {'mutation_type': 2, 'selection_coeff': 0.04658156633377075,
          'subpopulation': -1, 'slim_time': 0, 'nucleotide': -1}
       ]}}
    ], 'metadata': b''}

There were two mutations at this site, both before the SLiM portion of the simulation
started. One happened on the background of the other,
and no genomes either today or in the initial generation carry the first allele in isolation.
Their effects combine in SLiM, so treating this as a single allele is correct.

Now, we'll plot the initial and final allele frequencies,
with point size and color determined by the selection coefficient:

.. code-block:: python

   import matplotlib
   matplotlib.use('Agg')
   import matplotlib.pyplot as plt

   fig, ax1 = plt.subplots(figsize=(5, 4))
   dp = ax1.scatter(p[:, 0], p[:,1], c=s, s=s*800, label='frequencies')
   ax1.set_xlabel("initial allele frequency")
   ax1.set_ylabel("final allele frequency")
   fig.colorbar(dp, ax=ax1, label='selection coefficient')
   fig.savefig("annotated_p_vs_s.pdf")
   

This produces

.. image:: _static/annotated_p_vs_s.png


Unsurprisingly, mutations that had a large change in allele frequency seem
to be biased towards ones with higher selection coefficients.


*********************
Add neutral mutations
*********************

In real data, of course, we don't get to observe selection coefficients.
We haven't added in neutral mutations until this point for efficiency -
they are just bookkeeping, and do not affect the course of the simulation
in any way. For this reason, we can add them in after the fact, in a way
that is exactly equivalent to having kept track of them as we went along.

Recall that out of an overall mutation rate of 1e-8,
we wanted 97% of the mutations to be neutral on the ends of the chromosome,
and 99.7% to be neutral in the middle.
So, we'll now add mutations at these rates,
using the same model of mutation as before.
The code is nearly the same as before,
with a few changes.
We've changed the ``type`` of the mutations
(so that neutral mutations will show up in SLiM as m1,
while selected mutations above were m2),
and we've asked these mutations to have SLiM mutation IDs
beginning at the ID where the previous mutations left off.
(This would be important were we to read this tree sequence
back in to SLiM.)
And, importantly, we've added ``keep=True`` so that existing mutations
are not discarded, and ``allow_ancestral=True`` to allow new mutations
to be placed above existing ones (see :meth:`msprime.mutate` for more).

.. code-block:: python

   neutral_mut_map = msprime.RateMap(
               position=breaks,
               rate=[0.97e-8, 0.997e-8, 0.97e-8])
   next_id = max([max(map(int, m.derived_state.split(","))) for m in ts.mutations()])
   neutral_mut_model = msprime.SlimMutationModel(
            type=1,
            next_id=next_id)
   mts = msprime.mutate(ts, rate=neutral_mut_map, model=neutral_mut_model,
            discrete=True, random_seed=35,
            keep=True, allow_ancestral=True)
   print(f"The tree sequence now has {mts.num_mutations} mutations, at "
         f"{mts.num_sites} distinct sites.")
   # The tree sequence now has 32933 mutations, at 32876 distinct sites.

We've now got a lot more mutations!
And, we've got a lot more sites with multiple mutations:

.. code-block:: python

   num_alleles = np.array([len(s.mutations) for s in mts.sites()])
   for k in range(2, max(num_alleles)+1):
      print(f"There are {sum(num_alleles == k)} sites with {k} distinct alleles.")
   # There are 55 sites with 2 distinct alleles.
   # There are 1 sites with 3 distinct alleles.

OK, but how, exactly, is this working?
Can a neutral mutation be added to a site that previously had a selected mutation?
The short answer is: yes, and new alleles stack on top of
existing alleles, but existing alleles replace new alleles.
In more detail:
by the somewhat magical properties of Poisson processes,
adding neutral mutations using the same method,
ignoring the locations of any existing mutations,
is exactly equivalent to having put them down originally
along with the selected mutations.
(This is only true if we allow multiple mutations at a single site
in a single generation, but we haven't said exactly what these mutations *mean*,
so this is not wrong!)
Now, when the mutation algorithm in msprime puts down a new mutation
at a site with mutations already existing,
it appends the newly generated SLiM mutation ID to the previous derived state,
and adds the metadata for the new SLiM mutation to the list of metadata
from the previous mutation.
However, it doesn't modify any existing mutations,
so their derived states (and metadata) are unchanged.
The result is that, from the point of view of SLiM,
neutral ("m1") mutations "stack" on top of any other mutations (neutral or selected),
while selected ("m2") mutations stack with each other, but replace any neutral mutations.
This "stacking policy" is not actually exactly implementable in SLiM,
but given that our newly added mutations are meant to be entirely neutral,
seems like a reasonable policy.
If you wanted some other arrangement (e.g., to have m1 stack on top of m2),
you could go through and modify derived states and metadata appropriately.

Let's check if this has happened in this simulation:

.. code-block:: python
   
   for site in mts.sites():
      if len(site.mutations) > 1:
         types = [set([md["mutation_type"] for md in mut.metadata["mutation_list"]])
                  for mut in site.mutations]
         if max(map(len, types)) > 1:
            print(site)

There is indeed one such site:

.. code-block:: python

   {'id': 27527, 'position': 7431118.0, 'ancestral_state': '',
    'mutations': [
      {'id': 27582, 'site': 27527, 'node': 57046, 'time': 58179.527527578655,
       'derived_state': '509', 'parent': -1,
       'metadata': {'mutation_list': [
         {'mutation_type': 2, 'selection_coeff': 0.0339478924870491, 'subpopulation': -1, 'slim_time': 0, 'nucleotide': -1}
        ]}},
      {'id': 27583, 'site': 27527, 'node': 45789, 'time': 5178.611291860889,
       'derived_state': '509,28099', 'parent': 27582,
       'metadata': {'mutation_list': [
         {'mutation_type': 2, 'selection_coeff': 0.0339478924870491, 'subpopulation': -1, 'slim_time': 0, 'nucleotide': -1},
         {'mutation_type': 1, 'selection_coeff': 0.0, 'subpopulation': -1, 'slim_time': 0, 'nucleotide': -1}
        ]}}
    ], 'metadata': b''}

Here, a neutral mutation has been put down on top of a selected mutation,
but stacked, so that any samples inheriting either of these mutations carries
the selected mutation.
For more discussion of how this works, see :class:`msprime.SlimMutationModel`.


**************************
Diversity along the genome
**************************

Now that we've correctly added neutral mutations to the tree sequence,
and lengthily digested what exactly happened,
let's have a look at the result.
To do this, we'll compute two standard measures of genetic diversity
in windows along the genome:
Tajima's :math:`\pi` (also called "mean density of pairwise differences"
or "nucleotide diversity"), and Tajima's :math:`D` (with no known aliases).
This is easy to do thanks to the `statistics methods in tskit <https://tskit.readthedocs.io/en/latest/stats.html>`_.

.. code-block:: python

   windows = np.linspace(0, mts.sequence_length, 21)
   pi = mts.diversity(mts.samples(), windows=windows)
   taj_d = mts.Tajimas_D(mts.samples(), windows=windows)


   fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(6,3))
   mids = windows[1:] - np.diff(windows)/2
   ax1.set_xlabel("chromosome position (bp)")
   ax1.set_ylabel("pairwise diversity")
   ax1.plot(mids, pi, label="pairwise diversity")
   ax2.set_xlabel("chromosome position (bp)")
   ax2.set_ylabel("Tajima's D")
   ax2.plot(mids, taj_d, label="Tajima's D")
   fig.savefig("annotate_genome.pdf", bbox_inches='tight')

Here's what that looks like:

.. image:: _static/annotate_genome.png

The two statistics are very similar - perhaps unsurprisingly, because Tajima's D is calculated using
pairwise diversity, and we have a very large sample size (here, the entire population).
Tajima's D is negative across the entire genome, as the result of selection.
However, we don't see a strong difference between the three regions,
despite the stronger action of linked selection on the ends.
